# A0139820E
###### \bin\ruby\keyboardwarrior\ui\mainwindow.fxml
``` fxml
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.text.Font?>

<AnchorPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="600.0" prefWidth="1200.0" style="-fx-background-color: black;" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="ruby.keyboardwarrior.ui.MainWindow">
   <children>
      <TextField fx:id="commandInput" layoutX="513.0" layoutY="561.0" onAction="#onCommand" prefHeight="25.0" prefWidth="684.0" promptText="Enter command here" AnchorPane.bottomAnchor="5.0" AnchorPane.leftAnchor="5.0" AnchorPane.rightAnchor="5.0" />
      <TextArea fx:id="outputConsole" editable="false" layoutX="500.0" layoutY="147.0" prefHeight="565.0" prefWidth="632.0" wrapText="true" AnchorPane.bottomAnchor="35.0" AnchorPane.leftAnchor="5.0" AnchorPane.rightAnchor="602.0" AnchorPane.topAnchor="5.0">
         <font>
            <Font size="30.0" />
         </font></TextArea>
      <TextArea fx:id="TasksListView" editable="false" layoutX="746.0" layoutY="100.0" prefHeight="200.0" prefWidth="200.0" wrapText="true" AnchorPane.bottomAnchor="35.0" AnchorPane.leftAnchor="602.0" AnchorPane.rightAnchor="5.0" AnchorPane.topAnchor="5.0">
         <font>
            <Font size="20.0" />
         </font></TextArea>
   </children>
</AnchorPane>
```
###### \docs\DeveloperGuide.md
``` md

## Appendix A : User Stories

**Priorities**: High (must have) - `* * *`, Medium (nice to have)  - `* *`,  Low (unlikely to have) - `*`

Priority | As a ... | I want to ... | So that I can...
-------- | :------- | :--------- | :-----------
`* * *` | new user | see usage instructions | find out how to use the app
`* * *` | basic user | add an event with start and end time| know how long I need to spend on the event
`* * *` | basic user | add a deadline with date and time | decide what needs to be done soon
`* * *` | basic user | add a task with only description | record tasks that needs to be done some day
`* * *` | basic user | list all tasks that were added | can get a overview on all my tasks
`* * *` | basic user | find a specific task | refer to the task details quickly
`* * *` | basic user | edit a task | update the task details when I need to
`* * *` | basic user | delete a task | remove tasks that I no longer need to do
`* * *` | basic user | undo actions made | undo my mistakes quickly
`* * *` | basic user | be able to enter commands differently | have more flexibility in my commands
`* * *` | basic user | specify a folder as the data storage location | have more control on the where the data is stored
`* *` | intermediate user | add priority levels to my tasks | do more urgent tasks first
`* *` | intermediate user | clear all task that are completed | remove them at once instead individually
`* *` | intermediate user | add tags to my tasks | organize my tasks into different categories
`* *` | intermediate user | list all completed tasks | remove them if needed
`* *` | intermediate user | list all incomplete tasks | check on my progress
`* *` | intermediate user | see a list of commands I have added before | trace my action if needed
`* *` | intermediate user | redo an undone command | do not need to manually type out the changes if needed
`* *` | intermediate user | pin a tasks | keep important tasks at the top
`* *` | intermediate user | check time remaining | find out how much time remaining without manually calculating
`* *` | intermediate user | search for empty slots | I can find suitable slots to put in new tasks
`*` | advanced user | add weekly recurring tasks | do not need to add them individually
`*` | advanced user | sort my tasks in a specific order ( e.g. by priority, by date, by alphabetical) | easily find tasks in sequence
`*` | advanced user | see statistics on my tasks | know how many tasks I completed and did not complete
`*` | advanced user | reserve slots | avoid using the slots by mistake

```
###### \docs\DeveloperGuide.md
``` md

## Appendix B : Use Cases

`Software System:` **KeyboardWarrior** <br>
`Use case:` UC01 - Adding a calendar task <br>
`Actor:` User <br>
`MSS:` <br>
1. User chooses to add a calendar task. <br>
2. User types in command and required parameters. <br>
3. **KeyboardWarrior** displays task in Calendar pane. <br>
`Use case ends.` <br>
`Extensions:` <br>
2.a. **KeyboardWarrior** detects an error in the entered parameters. <br>
2.a.1. **KeyboardWarrior** requests for the correct parameters. <br>
2.a.2. User enters new parameters. <br>
Steps 2.a.1 - 2.a.2 are repeated until the parameters entered are correct. <br>
Use case resumes from step 3. <br>
`Use case ends.` <br>

--

`Software System:` **KeyboardWarrior** <br>
`Use case:` UC02 - Finding a task <br>
`Actor:` User <br>
`MSS:`  <br>
1. User chooses to find a task. <br>
2. User types in command and required parameters. <br>
3. **KeyboardWarrior** displays task on Calendar pane. <br>
`Use case ends.` <br>
`Extensions:` <br>
2.a. **KeyboardWarrior** does not find searched task. <br>
2.a.1. **KeyboardWarrior** notifies user that there is no such task. <br>
`Use case ends.` <br>

--

`Software System:` **KeyboardWarrior** <br>
`Use case:` UC03 - Complete todo task <br>
`Actor:` User <br>
`MSS:` <br>
1. User chooses to complete a Keep in View or Deadline. <br>
2. User types in command and required parameters. <br>
3. **KeyboardWarrior** removes task from Todo pane or Deadline pane. <br>
`Use case ends.` <br>
`Extensions:` <br>
2.a. **KeyboardWarrior** does not find searched task. <br>
2.a.1. **KeyboardWarrior** notifies user that there is no such task. <br>
`Use case ends.` <br>

```
###### \docs\DeveloperGuide.md
``` md

## Appendix C : Non Functional Requirements

* Should work on computers without internet connection.
* Should be fully CLI capable with keyboard shortcuts for mouse interactions.
*  Should work standalone in any mainstream operating system (OS) with Java 8 or higher installed.
* Should store data only in a human editable text file.
* Should be coded in OOP format.
* Should be able to hold at least 1000 individual task entries.
* Should take up less than 10mb storage space.
* Should come with automated unit tests and open source codes.
* Should work without any installer.
*  Should be able to process task efficiently by using efficient searching algorithms.
* Should be able to support command line interface.

```
###### \docs\DeveloperGuide.md
``` md

## Appendix D : Glossary

##### Mainstream OS

> Windows, Linux, Unix, OS-X

{TODO: Add more terms to Glossary}

## Appendix E : Product Survey

{TODO: Compare pros and cons}

####Google calendar
1.	Users can create multiple calendars for different usages.
2.	Contains a world clock feature
3.	Allows for specific location to be added to the events. (In the case of multiple possible locations for a place, e.g. Macdonald's)
4.	Pop up notifications for coming up events.
5.	'Find a time' feature to automatically look for empty slots for planning an event.
6.	Countdown timer popup window.
7.	Allows users to share their calendars with one another.
8.	Users can sync or import other calendar applications with google calendars to create a master calendar.

####Todo.txt
1.	A simple app that saves all task into a single "todo.txt" file
2.	Supports command line inputs (CLI)
3.	Allows grouping of related tasks into one project
4.	Allows for priority to be set to tasks and tasks will auto arrange themselves according to their priority
5.	Able to mark tasks as complete

####Fantastical 
1.	Supports syncing with other calendar apps such as Google Calendar.
2.	When scheduling a group event, allows you to quickly find out if coworkers are available during that duration (provided coworkers are using supported Calendar apps).
3.	Has a quick access 'mini-window' for your convenience.
4.	Has separate calendar sets based on your needs, e.g Leisure Calendar, Work Calendar, etc.
5.	Able to write in natural language style.
6.	Allows Day, Week, Month and Year views.
7.	Users can type in various languages such as Spanish or Japanese.

####Any.do Cal
1.	Supports syncing with other calendar apps such as Google Calendar
2.	Specializes only in showing your daily agenda with minimal clutter
3.	Allows Syncing with any-do so that your to-do list is also imported into the calendar.
```
###### \src\ruby\keyboardwarrior\storage\jaxb\AdaptedTask.java
``` java
/**
 * JAXB-friendly adapted person data holder class.
 */
public class AdaptedTask {

    @XmlElement(required = true)
    private String taskdetails;
 
    /**
     * No-arg constructor for JAXB use.
     */
    public AdaptedTask() {}


    /**
     * Converts a given Person into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created AdaptedPerson
     */
    public AdaptedTask(TodoTask source) {
        taskdetails = source.getDetails().details;
    }

    /**
     * Returns true if any required field is missing.
     *
     * JAXB does not enforce (required = true) without a given XML schema.
     * Since we do most of our validation using the data class constructors, the only extra logic we need
     * is to ensure that every xml element in the document is present. JAXB sets missing elements as null,
     * so we check for that.
     */
    public boolean isAnyRequiredFieldMissing() {
        return Utils.isAnyNull(taskdetails);
    }

    /**
     * Converts this jaxb-friendly adapted person object into the Person object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted person
     */
    public TodoTask toModelType() throws IllegalValueException {
        final TaskDetails task = new TaskDetails(this.taskdetails);
        return new TodoTask(task);
    }
}
```
###### \src\ruby\keyboardwarrior\storage\jaxb\AdaptedTasksList.java
``` java
/**
 * JAXB-friendly adapted address book data holder class.
 */
@XmlRootElement(name = "KeyboardWarrior")
public class AdaptedTasksList {

    @XmlElement
    private ArrayList<AdaptedTask> tasks = new ArrayList<>();

    /**
     * No-arg constructor for JAXB use.
     */
    public AdaptedTasksList() {}

    /**
     * Converts a given Keyboard Warrior into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created AdaptedAddressBook
     */
    public AdaptedTasksList(TasksList source) {
        tasks = new ArrayList<>();
        for (TodoTask task : source.getAllTasks()) {
            tasks.add(new AdaptedTask(task));
        }
    }


    /**
     * Returns true if any required field is missing.
     *
     * JAXB does not enforce (required = true) without a given XML schema.
     * Since we do most of our validation using the data class constructors, the only extra logic we need
     * is to ensure that every xml element in the document is present. JAXB sets missing elements as null,
     * so we check for that.
     */
    public boolean isAnyRequiredFieldMissing() {
        for (AdaptedTask task : tasks) {
            if (task.isAnyRequiredFieldMissing()) {
                return true;
            }
        }
        return false;
    }


    /**
     * Converts this jaxb-friendly {@code AdaptedTasksList} object into the corresponding(@code TasksList} object.
     * @throws IllegalValueException if there were any data constraints violated in the adapted person
     */
    public TasksList toModelType() throws IllegalValueException {
        final ArrayList<TodoTask> tasksList = new ArrayList<>();
        for (AdaptedTask task : tasks) {
            tasksList.add(task.toModelType());
        }
        return new TasksList(tasksList);
    }
}
```
###### \src\ruby\keyboardwarrior\storage\StorageFile.java
``` java
/**
 * Represents the file used to store address book data.
 */
public class StorageFile {

    /** Default file path used if the user doesn't provide the file name. */
    public static final String DEFAULT_STORAGE_FILEPATH = "keyboardwarrior.txt";

    /* Note: Note the use of nested classes below.
     * More info https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html
     */

    /**
     * Signals that the given file path does not fulfill the storage filepath constraints.
     */
    public static class InvalidStorageFilePathException extends IllegalValueException {
        public InvalidStorageFilePathException(String message) {
            super(message);
        }
    }

    /**
     * Signals that some error has occured while trying to convert and read/write data between the application
     * and the storage file.
     */
    public static class StorageOperationException extends Exception {
        public StorageOperationException(String message) {
            super(message);
        }
    }

    private final JAXBContext jaxbContext;

    public final Path path;

    /**
     * @throws InvalidStorageFilePathException if the default path is invalid
     */
    public StorageFile() throws InvalidStorageFilePathException {
        this(DEFAULT_STORAGE_FILEPATH);
    }

    /**
     * @throws InvalidStorageFilePathException if the given file path is invalid
     */
    public StorageFile(String filePath) throws InvalidStorageFilePathException {
        try {
            jaxbContext = JAXBContext.newInstance(AdaptedTasksList.class);
        } catch (JAXBException jaxbe) {
            throw new RuntimeException("jaxb initialisation error");
        }

        path = Paths.get(filePath);
        if (!isValidPath(path)) {
            throw new InvalidStorageFilePathException("Storage file should end with '.txt'");
        }
    }

    /**
     * Returns true if the given path is acceptable as a storage file.
     * The file path is considered acceptable if it ends with '.txt'
     */
    private static boolean isValidPath(Path filePath) {
    	String pathName = filePath.toString();
    	String extension = pathName.substring(pathName.lastIndexOf(".") + 1, pathName.length());
    	
    	if(extension.equals("txt"))
    		return true;
    	else
    		return false;
    }

    /**
     * Saves all data to this storage file.
     *
     * @throws StorageOperationException if there were errors converting and/or storing data to file.
     */
    public void save(TasksList tasksList) throws StorageOperationException {

        /* Note: Note the 'try with resource' statement below.
         * More info: https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html
         */
        try (final Writer fileWriter =
                     new BufferedWriter(new FileWriter(path.toFile()))) {

            final AdaptedTasksList toSave = new AdaptedTasksList(tasksList);
            final Marshaller marshaller = jaxbContext.createMarshaller();
            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
            marshaller.marshal(toSave, fileWriter);

        } catch (IOException ioe) {
            throw new StorageOperationException("Error writing to file: " + path + " error: " + ioe.getMessage());
        } catch (JAXBException jaxbe) {
            throw new StorageOperationException("Error converting Keyboard Warrior into storage format");
        }
    }

    /**
     * Loads data from this storage file.
     *
     * @throws StorageOperationException if there were errors reading and/or converting data from file.
     */
    public TasksList load() throws StorageOperationException {
        try (final Reader fileReader =
                     new BufferedReader(new FileReader(path.toFile()))) {

            final Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
            final AdaptedTasksList loaded = (AdaptedTasksList) unmarshaller.unmarshal(fileReader);
            // manual check for missing elements
            if (loaded.isAnyRequiredFieldMissing()) {
                throw new StorageOperationException("File data missing some elements");
            }
            return loaded.toModelType();

        /* Note: Here, we are using an exception to create the file if it is missing. However, we should minimize
         * using exceptions to facilitate normal paths of execution. If we consider the missing file as a 'normal'
         * situation (i.e. not truly exceptional) we should not use an exception to handle it.
         */

        // create empty file if not found
        } catch (FileNotFoundException fnfe) {
            final TasksList empty = new TasksList();
            save(empty);
            return empty;

        // other errors
        } catch (IOException ioe) {
            throw new StorageOperationException("Error writing to file: " + path);
        } catch (JAXBException jaxbe) {
            throw new StorageOperationException("Error parsing file data format");
        } catch (IllegalValueException ive) {
            throw new StorageOperationException("File contains illegal data values; data type constraints not met");
        }
    }

    public String getPath() {
        return path.toString();
    }

}
```
###### \src\ruby\keyboardwarrior\ui\mainwindow.fxml
``` fxml
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.text.Font?>

<AnchorPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="600.0" prefWidth="1200.0" style="-fx-background-color: black;" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="ruby.keyboardwarrior.ui.MainWindow">
   <children>
      <TextField fx:id="commandInput" layoutX="513.0" layoutY="561.0" onAction="#onCommand" prefHeight="25.0" prefWidth="684.0" promptText="Enter command here" AnchorPane.bottomAnchor="5.0" AnchorPane.leftAnchor="5.0" AnchorPane.rightAnchor="5.0" />
      <TextArea fx:id="outputConsole" editable="false" layoutX="500.0" layoutY="147.0" prefHeight="565.0" prefWidth="632.0" wrapText="true" AnchorPane.bottomAnchor="35.0" AnchorPane.leftAnchor="5.0" AnchorPane.rightAnchor="602.0" AnchorPane.topAnchor="5.0">
         <font>
            <Font size="30.0" />
         </font></TextArea>
      <TextArea fx:id="TasksListView" editable="false" layoutX="746.0" layoutY="100.0" prefHeight="200.0" prefWidth="200.0" wrapText="true" AnchorPane.bottomAnchor="35.0" AnchorPane.leftAnchor="602.0" AnchorPane.rightAnchor="5.0" AnchorPane.topAnchor="5.0">
         <font>
            <Font size="20.0" />
         </font></TextArea>
   </children>
</AnchorPane>
```
###### \src\ruby\keyboardwarrior\ui\MainWindow.java
``` java
/**
 * Main Window of the GUI.
 */
public class MainWindow {

    private Logic logic;
    private Stoppable mainApp;

    public MainWindow(){
    }

    public void setLogic(Logic logic){
        this.logic = logic;
    }

    public void setMainApp(Stoppable mainApp){
        this.mainApp = mainApp;
    }

    @FXML
    private TextArea outputConsole;
    
    @FXML
    private TextArea TasksListView;

    @FXML
    private TextField commandInput;


    @FXML
    void onCommand(ActionEvent event) {
        try {
            String userCommandText = commandInput.getText();
            CommandResult result = logic.execute(userCommandText);
            if(isExitCommand(result)){
                exitApp();
                return;
            }
            if(userCommandText.length() > 3 && (userCommandText.substring(0,4).equals("find") || userCommandText.substring(0,4).equals("list"))){
            	clearOutputConsole();
            	display(userCommandText);
            	displayAll(result);
            } else if(result.feedbackToUser.length() > 22 && result.feedbackToUser.substring(0,22).equals("Invalid command format")){
            	displayResult(result);
            } else {
            	displayResult(result);
            	displayAll(logic.execute("list"));
            }
            clearCommandInput();
        } catch (Exception e) {
            display(e.getMessage());
            throw new RuntimeException(e);
        }
    }

    private void exitApp() throws Exception {
        mainApp.stop();
    }

    /** Returns true of the result given is the result of an exit command */
    private boolean isExitCommand(CommandResult result) {
        return result.feedbackToUser.equals(ExitCommand.MESSAGE_EXIT_ACKNOWEDGEMENT);
    }

    /** Clears the command input box */
    private void clearCommandInput() {
        commandInput.setText("");
    }

    /** Clears the output display area */
    public void clearOutputConsole(){
        outputConsole.clear();
    }

    /** Displays the result of a command execution to the user. */
    public void displayResult(CommandResult result) {
        clearOutputConsole();
        final Optional<List<TodoTask>> resultTasks = result.getRelevantTasks();
        if(resultTasks.isPresent()) {
            display(resultTasks.get());
        }
        if(result.feedbackToUser.length() > 22 && result.feedbackToUser.substring(0,22).equals("Invalid command format")){
        	display("Invalid command format!");
        	displayAll(result.feedbackToUser.substring(25));
        } else {
        	display(result.feedbackToUser);
        }
    }

    public void displayWelcomeMessage(String version, String storageFilePath) throws Exception {
        String storageFileInfo = String.format(MESSAGE_USING_STORAGE_FILE, storageFilePath);
        display(MESSAGE_WELCOME, version, MESSAGE_PROGRAM_LAUNCH_ARGS_USAGE, storageFileInfo);
        displayAll(logic.execute("list"));
    }

    /**
     * Displays the list of persons in the output display area, formatted as an indexed list.
     */
    private void display(List<TodoTask> tasks) {
        display(new Formatter().format(tasks));
    }

    /**
     * Displays the given messages on the output display area, after formatting appropriately.
     */
    private void display(String... messages) {
    	clearOutputConsole();
        outputConsole.setText(outputConsole.getText() + new Formatter().format(messages));
    }
    
    /** Displays the result of a command execution to the user. */
    public void displayAll(CommandResult result) {
    	TasksListView.clear();
    	displayAll(result.feedbackToUser);
    	final Optional<List<TodoTask>> resultTasks = result.getRelevantTasks();
    	if(resultTasks.isPresent()) {
            displayAll(resultTasks.get());
        }
    }
    
    /**
     * Displays the entire list of tasks
     */
    private void displayAll(List<TodoTask> tasks){
        displayAll(new Formatter().format(tasks));
    }
    
    private void displayAll(String... messages){
    	TasksListView.clear();
        TasksListView.setText(TasksListView.getText() + new Formatter().format(messages));
    }
}
```
###### \test\java\ruby\keyboardwarrior\logic\LogicTest.java
``` java
public class LogicTest {

    /**
     * See https://github.com/junit-team/junit4/wiki/rules#temporaryfolder-rule
     */
    @Rule
    public TemporaryFolder saveFolder = new TemporaryFolder();

    private StorageFile saveFile;
    private TasksList tasksList;
    private Logic logic;

    @Before
    public void setup() throws Exception {
        saveFile = new StorageFile(saveFolder.newFile("testSaveFile.txt").getPath());
        tasksList = new TasksList();
        saveFile.save(tasksList);
        logic = new Logic(saveFile, tasksList);
    }

    @Test
    public void execute_invalid() throws Exception {
        String invalidCommand = "       ";
        assertCommandBehavior(invalidCommand,
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
    }

    /**
     * Executes the command and confirms that the result message is correct.
     * Both the 'address book' and the 'last shown list' are expected to be empty.
     * @see #assertCommandBehavior(String, String, TasksList, boolean, List)
     */
    private void assertCommandBehavior(String inputCommand, String expectedMessage) throws Exception {
        assertCommandBehavior(inputCommand, expectedMessage, TasksList.empty(),false, Collections.emptyList());
    }

    /**
     * Executes the command and confirms that the result message is correct and
     * also confirms that the following three parts of the Logic object's state are as expected:<br>
     *      - the internal address book data are same as those in the {@code expectedAddressBook} <br>
     *      - the internal 'last shown list' matches the {@code expectedLastList} <br>
     *      - the storage file content matches data in {@code expectedAddressBook} <br>
     */
    private void assertCommandBehavior(String inputCommand,
                                      String expectedMessage,
                                      TasksList expectedTasksList,
                                      boolean isRelevantTasksExpected,
                                      List<TodoTask> lastShownList) throws Exception {

        //Execute the command
        CommandResult r = logic.execute(inputCommand);

        //Confirm the result contains the right data
        assertEquals(expectedMessage, r.feedbackToUser);
        assertEquals(r.getRelevantTasks().isPresent(), isRelevantTasksExpected);
        if(isRelevantTasksExpected){
            assertEquals(lastShownList, r.getRelevantTasks().get());
        }

        //Confirm the state of data is as expected
        assertEquals(expectedTasksList, tasksList);
        assertEquals(lastShownList, logic.getLastShownList());
//        assertEquals(tasksList, saveFile.load());
    }


    @Test
    public void execute_unknownCommandWord() throws Exception {
        String unknownCommand = "uicfhmowqewca";
        assertCommandBehavior(unknownCommand, HelpCommand.MESSAGE_ALL_USAGES);
    }

    @Test
    public void execute_help() throws Exception {
        assertCommandBehavior("help", HelpCommand.MESSAGE_ALL_USAGES);
    }

    @Test
    public void execute_exit() throws Exception {
        assertCommandBehavior("exit", ExitCommand.MESSAGE_EXIT_ACKNOWEDGEMENT);
    }

    @Test
    public void execute_clear() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        tasksList.addTask(helper.generateTask(1));
        tasksList.addTask(helper.generateTask(2));
        tasksList.addTask(helper.generateTask(3));

        assertCommandBehavior("clear", ClearCommand.MESSAGE_SUCCESS, TasksList.empty(), false, Collections.emptyList());
    }

/*    @Test
    public void execute_add_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE);
        assertCommandBehavior(
                "add wrong args wrong args", expectedMessage);
        assertCommandBehavior(
                "add Valid Name 12345 e/valid@email.butNoPhonePrefix a/valid, address", expectedMessage);
        assertCommandBehavior(
                "add Valid Name p/12345 valid@email.butNoPrefix a/valid, address", expectedMessage);
        assertCommandBehavior(
                "add Valid Name p/12345 e/valid@email.butNoAddressPrefix valid, address", expectedMessage);
    }*/

/*    @Test
    public void execute_add_invalidTaskData() throws Exception {
        assertCommandBehavior(
                "add []\\[;] p/12345 e/valid@e.mail a/valid, address", TaskDetails.MESSAGE_DETAILS_CONSTRAINTS);
    }*/

    @Test
    public void execute_add_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        TodoTask toBeAdded = helper.aTasks();
        TasksList expectedAB = new TasksList();
        expectedAB.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                              String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded),
                              expectedAB,
                              false,
                              Collections.emptyList());

    }

    /*@Test
    public void execute_view_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewCommand.MESSAGE_USAGE);
        assertCommandBehavior("view ", expectedMessage);
        assertCommandBehavior("view arg not number", expectedMessage);
    }*/

    /*@Test
    public void execute_view_invalidIndex() throws Exception {
        assertInvalidIndexBehaviorForCommand("view");
    }*/

    /**
     * Confirms the 'invalid argument index number behaviour' for the given command
     * targeting a single person in the last shown list, using visible index.
     * @param commandWord to test assuming it targets a single person in the last shown list based on visible index.
     */
    private void assertInvalidIndexBehaviorForCommand(String commandWord) throws Exception {
        String expectedMessage = Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX;
        TestDataHelper helper = new TestDataHelper();
        TodoTask p1 = helper.generateTask(1);
        TodoTask p2 = helper.generateTask(2);
        List<TodoTask> lastShownList = helper.generateTaskList(p1, p2);

        logic.setLastShownList(lastShownList);

        assertCommandBehavior(commandWord + " -1", expectedMessage, TasksList.empty(), false, lastShownList);
        assertCommandBehavior(commandWord + " 0", expectedMessage, TasksList.empty(), false, lastShownList);
        assertCommandBehavior(commandWord + " 3", expectedMessage, TasksList.empty(), false, lastShownList);

    }

    /*@Test
    public void execute_view_onlyShowsNonPrivate() throws Exception {

        TestDataHelper helper = new TestDataHelper();
        Task p1 = helper.generateTask(1);
        Task p2 = helper.generateTask(2);
        List<Task> lastShownList = helper.generateTaskList(p1, p2);
        TasksList expectedAB = helper.generateTasksList(lastShownList);
        helper.addToTasksList(tasksList, lastShownList);

        logic.setLastShownList(lastShownList);

        assertCommandBehavior("view 1",
                              String.format(ViewCommand.MESSAGE_VIEW_TASK_DETAILS, p1.toString()),
                              expectedAB,
                              false,
                              lastShownList);

        assertCommandBehavior("view 2",
                              String.format(ViewCommand.MESSAGE_VIEW_TASK_DETAILS, p2.toString()),
                              expectedAB,
                              false,
                              lastShownList);
    }*/

    /*@Test
    public void execute_tryToViewMissingTask_errorMessage() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task p1 = helper.generateTask(1);
        Task p2 = helper.generateTask(2);
        List<Task> lastShownList = helper.generateTaskList(p1, p2);

        TasksList expectedAB = new TasksList();
        expectedAB.addTask(p2);

        tasksList.addTask(p2);
        logic.setLastShownList(lastShownList);

        assertCommandBehavior("view 1",
                              Messages.MESSAGE_TASK_NOT_IN_TASKSLIST,
                              expectedAB,
                              false,
                              lastShownList);
    }*/

    /*@Test
    public void execute_viewAll_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewAllCommand.MESSAGE_USAGE);
        assertCommandBehavior("viewall ", expectedMessage);
        assertCommandBehavior("viewall arg not number", expectedMessage);
    }*/

    /*@Test
    public void execute_viewAll_invalidIndex() throws Exception {
        assertInvalidIndexBehaviorForCommand("viewall");
    }*/

    /*@Test
    public void execute_viewAll() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task p1 = helper.generateTask(1);
        Task p2 = helper.generateTask(2);
        List<Task> lastShownList = helper.generateTaskList(p1, p2);
        TasksList expectedAB = helper.generateTasksList(lastShownList);
        helper.addToTasksList(tasksList, lastShownList);

        logic.setLastShownList(lastShownList);

        assertCommandBehavior("viewall 1",
                            String.format(ViewCommand.MESSAGE_VIEW_TASK_DETAILS, p1.toString()),
                            expectedAB,
                            false,
                            lastShownList);

        assertCommandBehavior("viewall 2",
                            String.format(ViewCommand.MESSAGE_VIEW_TASK_DETAILS, p2.toString()),
                            expectedAB,
                            false,
                            lastShownList);
    }*/

    /*@Test
    public void execute_tryToViewAllTaskMissingInTasksList_errorMessage() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task p1 = helper.generateTask(1);
        Task p2 = helper.generateTask(2);
        List<Task> lastShownList = helper.generateTaskList(p1, p2);

        TasksList expectedAB = new TasksList();
        expectedAB.addTask(p1);

        tasksList.addTask(p1);
        logic.setLastShownList(lastShownList);

        assertCommandBehavior("viewall 2",
                                Messages.MESSAGE_TASK_NOT_IN_TASKSLIST,
                                expectedAB,
                                false,
                                lastShownList);
    }*/

    @Test
    public void execute_delete_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE);
        assertCommandBehavior("delete ", expectedMessage);
        assertCommandBehavior("delete arg not number", expectedMessage);
    }

    @Test
    public void execute_delete_invalidIndex() throws Exception {
        assertInvalidIndexBehaviorForCommand("delete");
    }

    @Test
    public void execute_delete_removesCorrectTask() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        TodoTask p1 = helper.generateTask(1);
        TodoTask p2 = helper.generateTask(2);
        TodoTask p3 = helper.generateTask(3);

        List<TodoTask> threeTasks = helper.generateTaskList(p1, p2, p3);

        TasksList expectedAB = helper.generateTasksList(threeTasks);
        expectedAB.removeTask(p2);


        helper.addToTasksList(tasksList, threeTasks);
        logic.setLastShownList(threeTasks);

        assertCommandBehavior("delete 2",
                String.format(DeleteCommand.MESSAGE_DELETE_ITEM_SUCCESS, p2),
                                expectedAB,
                                false,
                                threeTasks);
    }

    @Test
    public void execute_delete_missingInTasksList() throws Exception {

        TestDataHelper helper = new TestDataHelper();
        TodoTask p1 = helper.generateTask(1);
        TodoTask p2 = helper.generateTask(2);
        TodoTask p3 = helper.generateTask(3);

        List<TodoTask> threeTasks = helper.generateTaskList(p1, p2, p3);

        TasksList expectedAB = helper.generateTasksList(threeTasks);
        expectedAB.removeTask(p2);

        helper.addToTasksList(tasksList, threeTasks);
        tasksList.removeTask(p2);
        logic.setLastShownList(threeTasks);

        assertCommandBehavior("delete 4",
                                Messages.MESSAGE_TASK_NOT_IN_TASKSLIST,
                                expectedAB,
                                false,
                                threeTasks);
    }

    @Test
    public void execute_find_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE);
        assertCommandBehavior("find ", expectedMessage);
    }

    @Test
    public void execute_find_onlyMatchesFullWordsInNames() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        TodoTask pTarget1 = helper.generateTaskWithDetails("bla bla KEY bla");
        TodoTask pTarget2 = helper.generateTaskWithDetails("bla KEY bla bceofeia");
        TodoTask p1 = helper.generateTaskWithDetails("KE Y");
        TodoTask p2 = helper.generateTaskWithDetails("KEYKEYKEY sduauo");

        List<TodoTask> fourTasks = helper.generateTaskList(p1, pTarget1, p2, pTarget2);
        TasksList expectedAB = helper.generateTasksList(fourTasks);
        List<TodoTask> expectedList = helper.generateTaskList(pTarget1, pTarget2);
        helper.addToTasksList(tasksList, fourTasks);

        assertCommandBehavior("find KEY",
                                Command.getMessageForTasksListShownSummary(expectedList),
                                expectedAB,
                                true,
                                expectedList);
    }

    // Might need to re-look this test
    @Test
    public void execute_find_isNonCaseSensitive() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        TodoTask pTarget1 = helper.generateTaskWithDetails("bla bla KEY bla");
        TodoTask pTarget2 = helper.generateTaskWithDetails("bla KEY bla bceofeia");
        TodoTask p1 = helper.generateTaskWithDetails("key key");
        TodoTask p2 = helper.generateTaskWithDetails("KEy sduauo");

        List<TodoTask> fourTasks = helper.generateTaskList(p1, pTarget1, p2, pTarget2);
        TasksList expectedAB = helper.generateTasksList(fourTasks);
        List<TodoTask> expectedList = helper.generateTaskList(p1, pTarget1, p2, pTarget2);
        helper.addToTasksList(tasksList, fourTasks);

        assertCommandBehavior("find KEY",
                                Command.getMessageForTasksListShownSummary(expectedList),                            
                                expectedAB,
                                true,
                                expectedList);
    }

    @Test
    public void execute_find_matchesIfAnyKeywordPresent() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        TodoTask pTarget1 = helper.generateTaskWithDetails("bla bla KEY bla");
        TodoTask pTarget2 = helper.generateTaskWithDetails("bla rAnDoM bla bceofeia");
        TodoTask p1 = helper.generateTaskWithDetails("key key");
        TodoTask p2 = helper.generateTaskWithDetails("KEy sduauo");

        List<TodoTask> fourTasks = helper.generateTaskList(p1, pTarget1, p2, pTarget2);
        TasksList expectedAB = helper.generateTasksList(fourTasks);
        List<TodoTask> expectedList = helper.generateTaskList(p1, pTarget1, p2, pTarget2);
        helper.addToTasksList(tasksList, fourTasks);

        assertCommandBehavior("find KEY rAnDoM",
                                Command.getMessageForTasksListShownSummary(expectedList),
                                expectedAB,
                                true,
                                expectedList);
    }

    /**
     * A utility class to generate test data.
     */
    class TestDataHelper{

        TodoTask aTasks() throws Exception {
            TaskDetails taskdetails = new TaskDetails("This is a task");
            return new TodoTask(taskdetails);
        }

        /**
         * Generates a valid task using the given seed.
         * Running this function with the same parameter values guarantees the returned task will have the same state.
         * Each unique seed will generate a unique Task object.
         *
         * @param seed used to generate the person data field values
         */
        TodoTask generateTask(int seed) throws Exception {
            return new TodoTask(new TaskDetails("Task " + seed));
        }

        /** Generates the correct add command based on the task given */
        String generateAddCommand(TodoTask p) {
            StringJoiner cmd = new StringJoiner(" ");

            cmd.add("add");

            cmd.add(p.getDetails().toString());
            return cmd.toString();
        }

        /**
         * Generates an TasksList based on the list of Tasks given.
         */
        TasksList generateTasksList(List<TodoTask> todoTasks) throws Exception{
            TasksList tasksList = new TasksList();
            addToTasksList(tasksList, todoTasks);
            return tasksList;
        }

        /**
         * Adds the given list of Tasks to the given TasksList
         */
        void addToTasksList(TasksList tasksList, List<TodoTask> tasksToAdd) throws Exception{
            for(TodoTask p: tasksToAdd){
                tasksList.addTask(p);
            }
        }

        /**
         * Creates a list of Tasks based on the given Task objects.
         */
        List<TodoTask> generateTaskList(TodoTask... tasks) throws Exception{
            List<TodoTask> taskList = new ArrayList<>();
            for(TodoTask p: tasks){
                taskList.add(p);
            }
            return taskList;
        }

        /**
         * Generates a Task object with given name. Other fields will have some dummy values.
         */
         TodoTask generateTaskWithDetails(String taskdetails) throws Exception {
            return new TodoTask(
                    new TaskDetails(taskdetails));
         }
    }

}
```

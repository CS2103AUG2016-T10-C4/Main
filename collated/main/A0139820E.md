# A0139820E
###### \ruby\keyboardwarrior\data\task\TaskDetails.java
``` java
/**
 * Represents the Task Details in the Keyboard Warrior.
 * Guarantees: immutable; is valid as declared in {@link #isValidDetails(String)}
 */
public class TaskDetails {

    public static final String EXAMPLE = "Do something";
    public static final String MESSAGE_DETAILS_CONSTRAINTS = "Invalid command format!";
    public static final String DETAILS_VALIDATION_REGEX = "[ {Alnum} ]+";

    public final String details;

    
    /**
     * Validates given details.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public TaskDetails(){
    	this.details = null;
    }
    
    /**
     * Validates given details.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public TaskDetails(String taskdetails){
        taskdetails = taskdetails.trim();
        this.details = taskdetails;
    }

    /**
     * Returns true if a given string is a valid detail.
     */
    public static boolean isValidDetails(String test) {
        return test.matches(DETAILS_VALIDATION_REGEX);
    }

    /**
     * Retrieves a listing of every word in the details, in order.
     */
    public List<String> getWordsInDetails() {
        return Arrays.asList(details.split("\\s+"));
    }

    /**
     * Overrides the toString method for details
     */
    @Override
    public String toString() {
        return details;
    }

    /**
     * Overrides the equals method for details
     */
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDetails // instanceof handles nulls
                && this.details.equals(((TaskDetails) other).details)); // state check
    }

    /**
     * Overrides the hash code for details
     */
    @Override
    public int hashCode() {
        return details.hashCode();
    }

}
```
###### \ruby\keyboardwarrior\data\TasksList.java
``` java
/**
 * Represents the entire Tasks List. Contains the data of the Keyboard Warrior.
 */
public class TasksList {


    private final ArrayList<Task> allTasks;
    private final UniqueTagList allTags;
    
    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicateTaskException extends DuplicateDataException {
        protected DuplicateTaskException() {
            super("Operation would result in duplicate task");
        }
    }
    
    /**
     * Signals that the Task given is not found.
     */
    public static class TaskNotFoundException extends IllegalValueException {
        public TaskNotFoundException() {
            super("No such Task can be found.");
        }
    }

    /**
     * Creates an empty Task List.
     */
    public TasksList() {
        this.allTasks = new ArrayList<Task>();
        this.allTags = new UniqueTagList();
    }

    /**
     * Constructs a Tasks List with the given data.
     */
    public TasksList(ArrayList<Task> tasks, UniqueTagList tags) {
        this.allTasks = new ArrayList<Task>(tasks);
        this.allTags = new UniqueTagList(tags);
        for (Task task : allTasks) {
            syncTagsWithMasterList(task);
        }
    }
    
    /**
     * Constructs a Tasks List with the given data.
     */
    public static TasksList empty() {
        return new TasksList();
    }
    
    /**
     * Ensures that every tag in this Task:
     *  - exists in the master list {@link #allTags}
     *  - points to a Tag object in the master list
     */
    private void syncTagsWithMasterList(Task task) {
        final UniqueTagList taskTags = task.getTags();
        this.allTags.mergeFrom(taskTags);

        // Create map with values = tag object references in the master list
        final Map<Tag, Tag> masterTagObjects = new HashMap<>();
        for (Tag tag : this.allTags) {
            masterTagObjects.put(tag, tag);
        }

        // Rebuild the list of Task tags using references from the master list
        final Set<Tag> commonTagReferences = new HashSet<>();
        for (Tag tag : taskTags) {
            commonTagReferences.add(masterTagObjects.get(tag));
        }
        task.setTags(new UniqueTagList(commonTagReferences));
    }

    /**
     * Adds a Task to the Tasks List.
     *
     * @throws DuplicateTaskException if an equivalent task already exists
     */
    public void addTask(Task toAdd) throws DuplicateTaskException{
        if (containsTask(toAdd)) {
            throw new DuplicateTaskException();
        }
        this.allTasks.add(toAdd);
    }
    
    /**
     * Inserts a Task to the Tasks List.
     *
     * @throws DuplicateTaskException if an equivalent task already exists
     */
    public void addTask(int index, Task toAdd) throws DuplicateTaskException{
        if (containsTask(toAdd)) {
            throw new DuplicateTaskException();
        }
        this.allTasks.add(index, toAdd);
    }

    /**
     * Checks if an equivalent Task exists in the Keyboard Warrior.
     */
    public boolean containsTask(Task key) {
        return this.allTasks.contains(key);
    }

    /**
     * Removes the equivalent Task from the Task List.
     *
     * @throws TaskNotFoundException if no such task could be found
     */
    public void removeTask(Task toRemove) throws TaskNotFoundException{
        if (!containsTask(toRemove)) {
            throw new TaskNotFoundException();
        }
        this.allTasks.remove(toRemove);
    }
    
    /**
     * Sets the equivalent Task from the Task List given a task.
     *
     * @throws TaskNotFoundException if no such Task could be found
     */
    public void setTask(Task toChange, Task editTask) throws TaskNotFoundException{
        if (!containsTask(toChange)) {
            throw new TaskNotFoundException();
        }
        this.allTasks.set(this.allTasks.indexOf(toChange), editTask);
    }
    
    /**
     * Sets the equivalent Task from the Task List given an Index.
     *
     * @throws TaskNotFoundException if no such Task could be found
     */
    public void setTask(Integer toChangeIndex, Task editTask){
        this.allTasks.set(toChangeIndex, editTask);
    }
  
    /**
     * Get method for the entire Task List.
     */
    public ArrayList<Task> getAllTasks(){
        return this.allTasks;
    }
    
    /**
     * Adds a Tag to the list of Tags present in the Task List.
     *
     * @throws DuplicateTagException if an equivalent Tag already exists
     */
    public void addTag(Tag toAdd) throws DuplicateTagException {
        allTags.add(toAdd);
    }
    
    /**
     * Checks if an equivalent Task exists in the Task List.
     */
    public boolean containsTag(Tag key) {
        return allTags.contains(key);
    }
    
    /**
     * Removes the equivalent Tag from the Task List.
     *
     * @throws TagNotFoundException if no such Tag could be found
     */
    public void removeTag(Tag toRemove) throws TagNotFoundException {
        this.allTags.remove(toRemove);
    }
    
    /**
     * Defensively copied UniqueTagList of all Tags in the Task List at the time of the call.
     */
    public UniqueTagList getAllTags() {
        return new UniqueTagList(this.allTags);
    }

    /**
     * Clears all tasks from the Tasks List.
     */
    public void clear() {
        allTasks.clear();
    }

    /**
     * Overrides the equals method for the Task list
     */
    @Override
    public boolean equals(Object other) {
        return other == this
                || (other instanceof TasksList
                && this.allTasks.equals(((TasksList) other).allTasks)
                && this.allTags.equals(((TasksList) other).allTags));
    }

    /**
     * Overrides the hash code method for the Task list
     */
    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(this.allTasks);
    }
}
```
###### \ruby\keyboardwarrior\storage\jaxb\AdaptedTask.java
``` java
/**
 * JAXB-friendly adapted Task data holder class.
 */
public class AdaptedTask {

    @XmlElement(required = true)
    private Integer taskType;
    @XmlElement(required = true)
    private TaskDetails taskDetails;
    @XmlElement(required = false)
    private Date date;
    @XmlElement(required = false)
    private DateTime startTime;
    @XmlElement(required = false)
    private DateTime endTime;
    @XmlElement
    private List<AdaptedTag> tagged = new ArrayList<>();
    
    /**
     * No-argument constructor for JAXB use.
     */
    public AdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created AdaptedPerson
     */
    public AdaptedTask(Task source) {
    	this.taskDetails = source.getDetails();
    	this.taskType = source.getTaskType();
    	this.date = source.getDate();
    	this.startTime = source.getStartTime();
    	this.endTime = source.getEndTime();
        this.tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            this.tagged.add(new AdaptedTag(tag));
        }
    }

    /**
     * Check if any of the required filed is missing.
     * 
     * @return true if missing
     */
    public boolean isAnyRequiredFieldMissing() {
        return Utils.isAnyNull(taskDetails) && Utils.isAnyNull(taskType);
    }

    /**
     * Converts this jaxb-friendly adapted task object into the Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted Task
     */
    public Task toModelType() throws IllegalValueException {
    	// Creates a new list of tags
        final List<Tag> taskTags = new ArrayList<>();
        for (AdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        
        // Creates a task with the unique tag list
        UniqueTagList tags = new UniqueTagList(taskTags);
        if(this.taskType == 0){
        	return new Task(this.taskDetails, tags);
        } else if(this.taskType == 1){
        	if(this.date == null)
        		return new Task(this.taskDetails, this.endTime, tags);
        	else
        	    return new Task(this.taskDetails, this.date, tags);
        } else {
        	return new Task(this.taskDetails, this.startTime, this.endTime, tags);
        }
    }
}
```
###### \ruby\keyboardwarrior\storage\jaxb\AdaptedTasksList.java
``` java
/**
 * JAXB-friendly adapted KeyboardWarrior data holder class.
 */
@XmlRootElement(name = "KeyboardWarrior")
public class AdaptedTasksList {

    @XmlElement
    private ArrayList<AdaptedTask> tasks = new ArrayList<>();
    @XmlElement
    private List<AdaptedTag> tags = new ArrayList<>();

    /**
     * No-argument constructor for JAXB use.
     */
    public AdaptedTasksList() {}

    /**
     * Converts a given Keyboard Warrior into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created AdaptedTaskList
     */
    public AdaptedTasksList(TasksList source) {
        tasks = new ArrayList<>();
        tags = new ArrayList<>();
        for (Task task : source.getAllTasks()) {
            tasks.add(new AdaptedTask(task));
        }
        for (Tag tag : source.getAllTags()) {
            tags.add(new AdaptedTag(tag));
        }
    }


    /**
     * Check if any of the required filed is missing.
     * 
     * @return true if missing
     */
    public boolean isAnyRequiredFieldMissing() {
        for (AdaptedTask task : tasks) {
            if (task.isAnyRequiredFieldMissing()) {
                return true;
            }
        }
        for (AdaptedTag tag : tags) {
            if (tag.isAnyRequiredFieldMissing()) {
                return true;
            }
        }
        return false;
    }


    /**
     * Converts this jaxb-friendly {@code AdaptedTasksList} object into the corresponding(@code TasksList} object.
     * 
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public TasksList toModelType() throws IllegalValueException {
        final ArrayList<Task> tasksList = new ArrayList<>();
        final List<Tag> tagList = new ArrayList<>();
        for (AdaptedTask task : tasks) {
            tasksList.add(task.toModelType());
        }
        for (AdaptedTag tag : tags) {
            tagList.add(tag.toModelType());
        }
        return new TasksList(tasksList, new UniqueTagList(tagList));
    }
}
```
###### \ruby\keyboardwarrior\storage\StorageFile.java
``` java
/**
 * Represents the file used to store address book data.
 */
public class StorageFile {

    /**
     * Default file path used if the user doesn't provide the file name.
     */
    public static final String DEFAULT_STORAGE_FILEPATH = "keyboardwarrior.txt";

    /**
     * Signals that the given file path does not fulfill the storage file path constraints.
     */
    public static class InvalidStorageFilePathException extends IllegalValueException {
        public InvalidStorageFilePathException(String message) {
            super(message);
        }
    }

    /**
     * Signals that some error has occurred while trying to convert and read/write data between the application
     * and the storage file.
     */
    public static class StorageOperationException extends Exception {
        public StorageOperationException(String message) {
            super(message);
        }
    }

    private final JAXBContext jaxbContext;

    public final Path path;

    /**
     * @throws InvalidStorageFilePathException if the default path is invalid
     */
    public StorageFile() throws InvalidStorageFilePathException {
        this(DEFAULT_STORAGE_FILEPATH);
    }

    /**
     * @throws InvalidStorageFilePathException if the given file path is invalid
     */
    public StorageFile(String filePath) throws InvalidStorageFilePathException {
        try {
            jaxbContext = JAXBContext.newInstance(AdaptedTasksList.class);
        } catch (JAXBException jaxbe) {
            throw new RuntimeException("jaxb initialisation error");
        }

        path = Paths.get(filePath);
        if (!isValidPath(path)) {
            throw new InvalidStorageFilePathException("Storage file should end with '.txt'");
        }
    }

    /**
     * Returns true if the given path is acceptable as a storage file.
     * The file path is considered acceptable if it ends with '.txt'
     */
    private static boolean isValidPath(Path filePath) {
    	String pathName = filePath.toString();
    	String extension = pathName.substring(pathName.lastIndexOf(".") + 1, pathName.length());
    	
    	if(extension.equals("txt"))
    		return true;
    	else
    		return false;
    }

    /**
     * Saves all data to this storage file.
     *
     * @throws StorageOperationException if there were errors converting and/or storing data to file.
     */
    public void save(TasksList tasksList) throws StorageOperationException {

        try (final Writer fileWriter = new BufferedWriter(new FileWriter(path.toFile()))) {
            final AdaptedTasksList toSave = new AdaptedTasksList(tasksList);
            final Marshaller marshaller = jaxbContext.createMarshaller();
            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
            marshaller.marshal(toSave, fileWriter);
        } catch (IOException ioe) {
            throw new StorageOperationException("Error writing to file: " + path + " error: " + ioe.getMessage());
        } catch (JAXBException jaxbe) {
            throw new StorageOperationException("Error converting Keyboard Warrior into storage format");
        }
    }

    /**
     * Loads data from this storage file.
     *
     * @throws StorageOperationException if there were errors reading and/or converting data from file.
     */
    public TasksList load() throws StorageOperationException {
        try (final Reader fileReader = new BufferedReader(new FileReader(path.toFile()))) {
            final Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
            final AdaptedTasksList loaded = (AdaptedTasksList) unmarshaller.unmarshal(fileReader);
            
            // A Manual check for missing elements
            if (loaded.isAnyRequiredFieldMissing()) {
                throw new StorageOperationException("File data missing some elements");
            }
            return loaded.toModelType();

        // Create empty file if not found
        } catch (FileNotFoundException fnfe) {
            final TasksList empty = new TasksList();
            save(empty);
            return empty;

        // Other errors
        } catch (IOException ioe) {
            throw new StorageOperationException("Error writing to file: " + path);
        } catch (JAXBException jaxbe) {
            throw new StorageOperationException("Error parsing file data format");
        } catch (IllegalValueException ive) {
            throw new StorageOperationException("File contains illegal data values; data type constraints not met");
        }
    }

    /**
     * Get method for file path.
     */
    public String getPath() {
        return path.toString();
    }

}
```
###### \ruby\keyboardwarrior\ui\mainwindow.fxml
``` fxml

<?import javafx.scene.control.Label?>
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.text.Font?>

<AnchorPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="600.0" prefWidth="1200.0" style="-fx-background-color: #003B46;" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="ruby.keyboardwarrior.ui.MainWindow">
   <children>
      <TextField fx:id="commandInput" layoutX="22.0" layoutY="548.0" onAction="#onCommand" prefHeight="30.0" prefWidth="1155.0" promptText="Enter command here" style="-fx-background-color: #C4DFE6;" stylesheets="@/ruby/keyboardwarrior/ui/Theme.css" AnchorPane.bottomAnchor="22.0" AnchorPane.leftAnchor="22.0" AnchorPane.rightAnchor="23.0" />
      <TextArea fx:id="outputWindow" editable="false" layoutX="22.0" layoutY="24.0" prefHeight="516.0" prefWidth="1155.0" style="-fx-background-color: white;" wrapText="true" AnchorPane.bottomAnchor="60.0" AnchorPane.leftAnchor="22.0" AnchorPane.rightAnchor="23.0" AnchorPane.topAnchor="24.0">
         <font>
            <Font size="18.0" />
         </font></TextArea>
      <Label fx:id="userAction" layoutX="22.0" layoutY="502.0" prefHeight="40.0" prefWidth="1155.0" style="-fx-background-color: #CFD4E6; -fx-padding: 10;" text="Welcome to Keyboard Warrior! Lets clear your Tasks together!" />
   </children>
</AnchorPane>
```
###### \ruby\keyboardwarrior\ui\MainWindow.java
``` java
/**
 * Main Window of the GUI.
 */
public class MainWindow {

    private Logic logic;
    private Stoppable mainApp;

    /**
     * No-argument constructor for JAXB use.
     */
    public MainWindow(){
    }

    /**
     * Set method for Logic.
     */
    public void setLogic(Logic logic){
        this.logic = logic;
    }

    /**
     * Set method for the main Application.
     */
    public void setMainApp(Stoppable mainApp){
        this.mainApp = mainApp;
    }
    
    
    /**
     * The FXML elements of the GUI.
     */
    @FXML
    private TextArea outputWindow;
    @FXML
    private TextField commandInput;
    @FXML
    private Label userAction;

    /**
     * Executes the user input when the enter button is pressed. 
     * @throws Exception 
     */
    @FXML
    void onCommand(ActionEvent event) throws Exception {
    	clearOutputWindow();
        String userCommandText = commandInput.getText();
        CommandResult result = logic.execute(userCommandText);
        
        // Execute if the user inputs exit
        if(isExitCommand(result)){
        	exitApp();
        }
        
        displayResult(result, true);
        clearCommandInput();
    }

    /**
     * Exits the application.
     */
    private void exitApp() throws Exception {
        mainApp.stop();
    }

    /**
     * Returns true if the result given is of an exit command.
     */
    private boolean isExitCommand(CommandResult result) {
        return result.feedbackToUser.equals(ExitCommand.MESSAGE_EXIT_ACKNOWEDGEMENT);
    }

    /**
     * Clears the command input box.
     */
    private void clearCommandInput() {
        commandInput.clear();
    }
    
    /**
     * Clears the task list view.
     */
    private void clearOutputWindow() {
    	outputWindow.clear();
    }

    /**
     * Displays the welcome messages of the application.
     */
    public void displayWelcomeMessage(String version, String storageFilePath) throws Exception {
        String storageFileInfo = String.format(MESSAGE_USING_STORAGE_FILE, storageFilePath);
        displayMessages(MESSAGE_WELCOME + version, storageFileInfo + "\n");
		displayResult(logic.execute(ListCommand.COMMAND_WORD), false);
        fadingLabel();
    }
    
    /**
     * Displays the result of a command execution to the user.
     */
    public void displayResult(CommandResult result, boolean withFeedback) {
    	final Optional<List<Task>> resultTasks = result.getRelevantTasks();
    	final String resultString = result.displayToUser;
    	final String userFeedback = result.feedbackToUser;
    	if(resultString != "") {	
    		displayMessages(resultString);
        }
    	if(resultTasks.isPresent()) {
    		List<ArrayList<Task>> sortedTaskList = sortTask(resultTasks.get());
    		displayAllTask(sortedTaskList);
        }
    	if(withFeedback)
    		displayFeedback(userFeedback);
    }
    
    /**
     * Sorts the entire list of tasks into their specific category.
     */
    private List<ArrayList<Task>> sortTask(List<Task> tasks){
    	List<ArrayList<Task>> sortedTask = new ArrayList<ArrayList<Task>>();
    	sortedTask.add(obtainSpecificTaskList(tasks, 0));
    	sortedTask.add(obtainSpecificTaskList(tasks, 1));
    	sortedTask.add(obtainSpecificTaskList(tasks, 2));
    	return sortedTask;
    }
    
    /**
     * Obtain a list of one specific task type.
     */
    private ArrayList<Task> obtainSpecificTaskList(List<Task> tasks, Integer taskType){
    	ArrayList<Task> specificTaskList = new ArrayList<Task>();
    	for(Task task: tasks){
    		if(task.getTaskType() == taskType)
    			specificTaskList.add(task);
    	}
    	return specificTaskList;
    }
    
    /**
     * Displays all the types of task to the user.
     */
    private void displayAllTask(List<ArrayList<Task>> sortedTaskList){
    	displayTask(sortedTaskList.get(0), Messages.MESSAGE_TODO_LIST);
    	displayTask(sortedTaskList.get(1), Messages.MESSAGE_DEADLINE_LIST);
    	displayTask(sortedTaskList.get(2), Messages.MESSAGE_EVENT_LIST);
    }
    
    /**
     * Displays the task to the user.
     */
    private void displayTask(List<Task> tasks, String message){
    	if(!tasks.isEmpty()){
    		displayMessages(String.format(message, tasks.size()));
    	  	displayMessages(new Formatter().format(tasks));
    	}
    }
    
    /**
     * Displays the messages to the user.
     */
    private void displayMessages(String... messages){
    	outputWindow.setText(outputWindow.getText() + new Formatter().format(messages));
    }
   
    /**
     * Display a fading Label containing the feedback from the application.
     */
	private void displayFeedback(String displayToUser){
		userAction.setText(new Formatter().format(displayToUser));
        fadingLabel();
	}
	
    /**
     * Runs a fading transition for the Label.
     */
	private void fadingLabel(){
        FadeTransition fadeOut = new FadeTransition(Duration.seconds(10), userAction);
        fadeOut.setFromValue(1.0);
        fadeOut.setToValue(0.0);
        fadeOut.play();
	}
}
```

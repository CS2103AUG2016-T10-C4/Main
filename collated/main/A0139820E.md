# A0139820E
###### \bin\ruby\keyboardwarrior\ui\mainwindow.fxml
``` fxml
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.text.Font?>

<AnchorPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="600.0" prefWidth="1200.0" style="-fx-background-color: black;" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="ruby.keyboardwarrior.ui.MainWindow">
   <children>
      <TextField fx:id="commandInput" layoutX="513.0" layoutY="561.0" onAction="#onCommand" prefHeight="25.0" prefWidth="684.0" promptText="Enter command here" AnchorPane.bottomAnchor="5.0" AnchorPane.leftAnchor="5.0" AnchorPane.rightAnchor="5.0" />
      <TextArea fx:id="outputConsole" editable="false" layoutX="500.0" layoutY="147.0" prefHeight="565.0" prefWidth="632.0" wrapText="true" AnchorPane.bottomAnchor="35.0" AnchorPane.leftAnchor="5.0" AnchorPane.rightAnchor="602.0" AnchorPane.topAnchor="5.0">
         <font>
            <Font size="30.0" />
         </font></TextArea>
      <TextArea fx:id="TasksListView" editable="false" layoutX="746.0" layoutY="100.0" prefHeight="200.0" prefWidth="200.0" wrapText="true" AnchorPane.bottomAnchor="35.0" AnchorPane.leftAnchor="602.0" AnchorPane.rightAnchor="5.0" AnchorPane.topAnchor="5.0">
         <font>
            <Font size="20.0" />
         </font></TextArea>
   </children>
</AnchorPane>
```
###### \src\ruby\keyboardwarrior\data\task\TaskDetails.java
``` java
/**
 * Represents the Task Details in the Keyboard Warrior.
 * Guarantees: immutable; is valid as declared in {@link #isValidDetails(String)}
 */
public class TaskDetails {

    public static final String EXAMPLE = "Do something";
    public static final String MESSAGE_DETAILS_CONSTRAINTS = "Invalid command format!";
    public static final String DETAILS_VALIDATION_REGEX = "[ {Alnum} ]+";

    public final String details;

    /**
     * Validates given details.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public TaskDetails(String taskdetails){
        taskdetails = taskdetails.trim();
        this.details = taskdetails;
    }

    /**
     * Returns true if a given string is a valid detail.
     */
    public static boolean isValidDetails(String test) {
        return test.matches(DETAILS_VALIDATION_REGEX);
    }

    /**
     * Retrieves a listing of every word in the details, in order.
     */
    public List<String> getWordsInDetails() {
        return Arrays.asList(details.split("\\s+"));
    }

    @Override
    public String toString() {
        return details;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDetails // instanceof handles nulls
                && this.details.equals(((TaskDetails) other).details)); // state check
    }

    @Override
    public int hashCode() {
        return details.hashCode();
    }

}
```
###### \src\ruby\keyboardwarrior\data\TasksList.java
``` java
/**
 * Represents the entire tasks list. Contains the data of the keyboard warrior.
 */
public class TasksList {


    private static ArrayList<Task> allTasks = new ArrayList<Task>();
    
    public static class DuplicateTaskException extends DuplicateDataException {
        protected DuplicateTaskException() {
            super("Operation would result in duplicate task");
        }
    }
    
    /**
     * Signals that the task given is not found.
     */
    public static class TaskNotFoundException extends IllegalValueException {
        public TaskNotFoundException() {
            super("No such Task can be found.");
        }
    }

    public static TasksList empty() {
        return new TasksList();
    }

    /**
     * Creates an empty address book.
     */
    public TasksList() {
        allTasks = new ArrayList<Task>();
    }

    /**
     * Constructs a taskslist with the given data.
     */
    public TasksList(ArrayList<Task> tasks) {
        this.allTasks = new ArrayList<Task>(tasks);
    }

    /**
     * Adds a task to the tasks list.
     *
     * @throws DuplicateTaskException if an equivalent task already exists.
     */
    public void addTask(Task toAdd) throws DuplicateTaskException{
        if (containsTask(toAdd)) {
            throw new DuplicateTaskException();
        }
        allTasks.add(toAdd);
    }
    
    /**
     * Inserts a task to the tasks list.
     *
     * @throws DuplicateTaskException if an equivalent task already exists.
     */
    public void addTask(int index, Task toAdd) throws DuplicateTaskException{
        if (containsTask(toAdd)) {
            throw new DuplicateTaskException();
        }
        allTasks.add(index, toAdd);
    }

    /**
     * Checks if an equivalent task exists in the keyboard warrior.
     */
    public boolean containsTask(Task key) {
        return allTasks.contains(key);
    }

    /**
     * Removes the equivalent task from the address book.
     *
     * @throws TaskNotFoundException if no such task could be found.
     */
    public void removeTask(Task toRemove) throws TaskNotFoundException{
        if (!containsTask(toRemove)) {
            throw new TaskNotFoundException();
        }
        allTasks.remove(toRemove);
    }
    
    /**
     * Sets the equivalent Task from the Task Manager.
     *
     * @throws TaskNotFoundException if no such Task could be found.
     */
    public void setTask(Task toChange, Task editTask) throws TaskNotFoundException{
        if (!containsTask(toChange)) {
            throw new TaskNotFoundException();
        }
        allTasks.set(allTasks.indexOf(toChange), editTask);
    }
    
    public void setTask(int toChangeIndex, Task editTask){
        allTasks.set(toChangeIndex, editTask);
    }
  
    public static List<Task> getAllTasks(){

        return allTasks;
    }

    /**
     * Clears all tasks from the tasks list.
     */
    public void clear() {
        allTasks.clear();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TasksList // instanceof handles nulls
                && this.allTasks.equals(((TasksList) other).allTasks));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(allTasks);
    }
}
```
###### \src\ruby\keyboardwarrior\storage\jaxb\AdaptedTask.java
``` java
/**
 * JAXB-friendly adapted person data holder class.
 */
public class AdaptedTask {

    @XmlElement(required = true)
    private String taskdetails;
 
    /**
     * No-arg constructor for JAXB use.
     */
    public AdaptedTask() {}


    /**
     * Converts a given Person into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created AdaptedPerson
     */
    public AdaptedTask(Task source) {
        this.taskdetails = source.toString();
    }

    /**
     * Returns true if any required field is missing.
     *
     * JAXB does not enforce (required = true) without a given XML schema.
     * Since we do most of our validation using the data class constructors, the only extra logic we need
     * is to ensure that every xml element in the document is present. JAXB sets missing elements as null,
     * so we check for that.
     */
    public boolean isAnyRequiredFieldMissing() {
        return Utils.isAnyNull(taskdetails);
    }

    /**
     * Converts this jaxb-friendly adapted person object into the Person object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted person
     */
    public Task toModelType() throws IllegalValueException {
        final TaskDetails task = new TaskDetails(this.taskdetails);
        return new Task(task);
    }
}
```
###### \src\ruby\keyboardwarrior\storage\jaxb\AdaptedTasksList.java
``` java
/**
 * JAXB-friendly adapted address book data holder class.
 */
@XmlRootElement(name = "KeyboardWarrior")
public class AdaptedTasksList {

    @XmlElement
    private ArrayList<AdaptedTask> tasks = new ArrayList<>();

    /**
     * No-arg constructor for JAXB use.
     */
    public AdaptedTasksList() {}

    /**
     * Converts a given Keyboard Warrior into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created AdaptedAddressBook
     */
    public AdaptedTasksList(TasksList source) {
        tasks = new ArrayList<>();
        for (Task task : source.getAllTasks()) {
            tasks.add(new AdaptedTask(task));
        }
    }


    /**
     * Returns true if any required field is missing.
     *
     * JAXB does not enforce (required = true) without a given XML schema.
     * Since we do most of our validation using the data class constructors, the only extra logic we need
     * is to ensure that every xml element in the document is present. JAXB sets missing elements as null,
     * so we check for that.
     */
    public boolean isAnyRequiredFieldMissing() {
        for (AdaptedTask task : tasks) {
            if (task.isAnyRequiredFieldMissing()) {
                return true;
            }
        }
        return false;
    }


    /**
     * Converts this jaxb-friendly {@code AdaptedTasksList} object into the corresponding(@code TasksList} object.
     * @throws IllegalValueException if there were any data constraints violated in the adapted person
     */
    public TasksList toModelType() throws IllegalValueException {
        final ArrayList<Task> tasksList = new ArrayList<>();
        for (AdaptedTask task : tasks) {
            tasksList.add(task.toModelType());
        }
        return new TasksList(tasksList);
    }
}
```
###### \src\ruby\keyboardwarrior\storage\StorageFile.java
``` java
/**
 * Represents the file used to store address book data.
 */
public class StorageFile {

    /** Default file path used if the user doesn't provide the file name. */
    public static final String DEFAULT_STORAGE_FILEPATH = "keyboardwarrior.txt";

    /* Note: Note the use of nested classes below.
     * More info https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html
     */

    /**
     * Signals that the given file path does not fulfill the storage filepath constraints.
     */
    public static class InvalidStorageFilePathException extends IllegalValueException {
        public InvalidStorageFilePathException(String message) {
            super(message);
        }
    }

    /**
     * Signals that some error has occured while trying to convert and read/write data between the application
     * and the storage file.
     */
    public static class StorageOperationException extends Exception {
        public StorageOperationException(String message) {
            super(message);
        }
    }

    private final JAXBContext jaxbContext;

    public final Path path;

    /**
     * @throws InvalidStorageFilePathException if the default path is invalid
     */
    public StorageFile() throws InvalidStorageFilePathException {
        this(DEFAULT_STORAGE_FILEPATH);
    }

    /**
     * @throws InvalidStorageFilePathException if the given file path is invalid
     */
    public StorageFile(String filePath) throws InvalidStorageFilePathException {
        try {
            jaxbContext = JAXBContext.newInstance(AdaptedTasksList.class);
        } catch (JAXBException jaxbe) {
            throw new RuntimeException("jaxb initialisation error");
        }

        path = Paths.get(filePath);
        if (!isValidPath(path)) {
            throw new InvalidStorageFilePathException("Storage file should end with '.txt'");
        }
    }

    /**
     * Returns true if the given path is acceptable as a storage file.
     * The file path is considered acceptable if it ends with '.txt'
     */
    private static boolean isValidPath(Path filePath) {
    	String pathName = filePath.toString();
    	String extension = pathName.substring(pathName.lastIndexOf(".") + 1, pathName.length());
    	
    	if(extension.equals("txt"))
    		return true;
    	else
    		return false;
    }

    /**
     * Saves all data to this storage file.
     *
     * @throws StorageOperationException if there were errors converting and/or storing data to file.
     */
    public void save(TasksList tasksList) throws StorageOperationException {

        /* Note: Note the 'try with resource' statement below.
         * More info: https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html
         */
        try (final Writer fileWriter =
                     new BufferedWriter(new FileWriter(path.toFile()))) {

            final AdaptedTasksList toSave = new AdaptedTasksList(tasksList);
            final Marshaller marshaller = jaxbContext.createMarshaller();
            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
            marshaller.marshal(toSave, fileWriter);

        } catch (IOException ioe) {
            throw new StorageOperationException("Error writing to file: " + path + " error: " + ioe.getMessage());
        } catch (JAXBException jaxbe) {
            throw new StorageOperationException("Error converting Keyboard Warrior into storage format");
        }
    }

    /**
     * Loads data from this storage file.
     *
     * @throws StorageOperationException if there were errors reading and/or converting data from file.
     */
    public TasksList load() throws StorageOperationException {
        try (final Reader fileReader =
                     new BufferedReader(new FileReader(path.toFile()))) {

            final Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
            final AdaptedTasksList loaded = (AdaptedTasksList) unmarshaller.unmarshal(fileReader);
            // manual check for missing elements
            if (loaded.isAnyRequiredFieldMissing()) {
                throw new StorageOperationException("File data missing some elements");
            }
            return loaded.toModelType();

        /* Note: Here, we are using an exception to create the file if it is missing. However, we should minimize
         * using exceptions to facilitate normal paths of execution. If we consider the missing file as a 'normal'
         * situation (i.e. not truly exceptional) we should not use an exception to handle it.
         */

        // create empty file if not found
        } catch (FileNotFoundException fnfe) {
            final TasksList empty = new TasksList();
            save(empty);
            return empty;

        // other errors
        } catch (IOException ioe) {
            throw new StorageOperationException("Error writing to file: " + path);
        } catch (JAXBException jaxbe) {
            throw new StorageOperationException("Error parsing file data format");
        } catch (IllegalValueException ive) {
            throw new StorageOperationException("File contains illegal data values; data type constraints not met");
        }
    }

    public String getPath() {
        return path.toString();
    }

}
```
###### \src\ruby\keyboardwarrior\ui\mainwindow.fxml
``` fxml
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.text.Font?>

<AnchorPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="600.0" prefWidth="1200.0" style="-fx-background-color: black;" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="ruby.keyboardwarrior.ui.MainWindow">
   <children>
      <TextField fx:id="commandInput" layoutX="513.0" layoutY="561.0" onAction="#onCommand" prefHeight="25.0" prefWidth="684.0" promptText="Enter command here" AnchorPane.bottomAnchor="5.0" AnchorPane.leftAnchor="5.0" AnchorPane.rightAnchor="5.0" />
      <TextArea fx:id="outputConsole" editable="false" layoutX="500.0" layoutY="147.0" prefHeight="565.0" prefWidth="632.0" wrapText="true" AnchorPane.bottomAnchor="35.0" AnchorPane.leftAnchor="5.0" AnchorPane.rightAnchor="602.0" AnchorPane.topAnchor="5.0">
         <font>
            <Font size="30.0" />
         </font></TextArea>
      <TextArea fx:id="TasksListView" editable="false" layoutX="746.0" layoutY="100.0" prefHeight="200.0" prefWidth="200.0" wrapText="true" AnchorPane.bottomAnchor="35.0" AnchorPane.leftAnchor="602.0" AnchorPane.rightAnchor="5.0" AnchorPane.topAnchor="5.0">
         <font>
            <Font size="20.0" />
         </font></TextArea>
   </children>
</AnchorPane>
```
###### \src\ruby\keyboardwarrior\ui\MainWindow.java
``` java
/**
 * Main Window of the GUI.
 */
public class MainWindow {

    private Logic logic;
    private Stoppable mainApp;

    public MainWindow(){
    }

    public void setLogic(Logic logic){
        this.logic = logic;
    }

    public void setMainApp(Stoppable mainApp){
        this.mainApp = mainApp;
    }

    @FXML
    private TextArea outputConsole;
    
    @FXML
    private TextArea TasksListView;

    @FXML
    private TextField commandInput;


    @FXML
    void onCommand(ActionEvent event) {
        try {
            String userCommandText = commandInput.getText();
            CommandResult result = logic.execute(userCommandText);
            if(isExitCommand(result)){
                exitApp();
                return;
            }
            if(userCommandText.length() > 3 && (userCommandText.substring(0,4).equals("find") || userCommandText.substring(0,4).equals("list"))){
            	clearOutputConsole();
            	display(userCommandText);
            	displayAll(result);
            } else if(result.feedbackToUser.length() > 22 && result.feedbackToUser.substring(0,22).equals("Invalid command format")){
            	displayResult(result);
            } else {
            	displayResult(result);
            	displayAll(logic.execute("list"));
            }
            clearCommandInput();
        } catch (Exception e) {
            display(e.getMessage());
            throw new RuntimeException(e);
        }
    }

    private void exitApp() throws Exception {
        mainApp.stop();
    }

    /** Returns true of the result given is the result of an exit command */
    private boolean isExitCommand(CommandResult result) {
        return result.feedbackToUser.equals(ExitCommand.MESSAGE_EXIT_ACKNOWEDGEMENT);
    }

    /** Clears the command input box */
    private void clearCommandInput() {
        commandInput.setText("");
    }

    /** Clears the output display area */
    public void clearOutputConsole(){
        outputConsole.clear();
    }

    /** Displays the result of a command execution to the user. */
    public void displayResult(CommandResult result) {
        clearOutputConsole();
        TasksListView.clear();
        final Optional<List<Task>> resultTasks = result.getRelevantTasks();
        if(resultTasks.isPresent()) {
            display(resultTasks.get());
        }
        if(result.feedbackToUser.length() > 22 && result.feedbackToUser.substring(0,22).equals("Invalid command format")){
        	display("Invalid command format!");
        	displayAll(result.feedbackToUser.substring(25));
        } else {
        	display(result.feedbackToUser);
        }
    }

    public void displayWelcomeMessage(String version, String storageFilePath) throws Exception {
        String storageFileInfo = String.format(MESSAGE_USING_STORAGE_FILE, storageFilePath);
        display(MESSAGE_WELCOME, version, MESSAGE_PROGRAM_LAUNCH_ARGS_USAGE, storageFileInfo);
        displayAll(logic.execute("list"));
    }

    /**
     * Displays the list of persons in the output display area, formatted as an indexed list.
     */
    private void display(List<Task> tasks) {
        display(new Formatter().format(tasks));
    }

    /**
     * Displays the given messages on the output display area, after formatting appropriately.
     */
    private void display(String... messages) {
    	clearOutputConsole();
        outputConsole.setText(outputConsole.getText() + new Formatter().format(messages));
    }
    
    /** Displays the result of a command execution to the user. */
    public void displayAll(CommandResult result) {
    	TasksListView.clear();
    	displayAll(result.feedbackToUser);
    	final Optional<List<Task>> resultTasks = result.getRelevantTasks();
    	if(resultTasks.isPresent()) {
            displayAll(resultTasks.get());
        }
    }
    
    /**
     * Displays the entire list of tasks
     */
    private void displayAll(List<Task> tasks){
        displayAll(new Formatter().format(tasks));
    }
    
    private void displayAll(String... messages){
        TasksListView.setText(TasksListView.getText() + new Formatter().format(messages));
    }
}
```
###### \test\java\ruby\keyboardwarrior\logic\LogicTest.java
``` java
public class LogicTest {

    /**
     * See https://github.com/junit-team/junit4/wiki/rules#temporaryfolder-rule
     */
    @Rule
    public TemporaryFolder saveFolder = new TemporaryFolder();

    private StorageFile saveFile;
    private TasksList tasksList;
    private Logic logic;

    @Before
    public void setup() throws Exception {
        saveFile = new StorageFile(saveFolder.newFile("testSaveFile.txt").getPath());
        tasksList = new TasksList();
        saveFile.save(tasksList);
        logic = new Logic(saveFile, tasksList);
    }

    @Test
    public void constructor() {
        //Constructor is called in the setup() method which executes before every test, no need to call it here again.

        //Confirm the last shown list is empty
        assertEquals(Collections.emptyList(), logic.getLastShownList());
    }

    @Test
    public void execute_invalid() throws Exception {
        String invalidCommand = "       ";
        assertCommandBehavior(invalidCommand,
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
    }

    /**
     * Executes the command and confirms that the result message is correct.
     * Both the 'address book' and the 'last shown list' are expected to be empty.
     * @see #assertCommandBehavior(String, String, TasksList, boolean, List)
     */
    private void assertCommandBehavior(String inputCommand, String expectedMessage) throws Exception {
        assertCommandBehavior(inputCommand, expectedMessage, TasksList.empty(),false, Collections.emptyList());
    }

    /**
     * Executes the command and confirms that the result message is correct and
     * also confirms that the following three parts of the Logic object's state are as expected:<br>
     *      - the internal address book data are same as those in the {@code expectedAddressBook} <br>
     *      - the internal 'last shown list' matches the {@code expectedLastList} <br>
     *      - the storage file content matches data in {@code expectedAddressBook} <br>
     */
    private void assertCommandBehavior(String inputCommand,
                                      String expectedMessage,
                                      TasksList expectedTasksList,
                                      boolean isRelevantTasksExpected,
                                      List<Task> lastShownList) throws Exception {

        //Execute the command
        CommandResult r = logic.execute(inputCommand);

        //Confirm the result contains the right data
        assertEquals(expectedMessage, r.feedbackToUser);
        assertEquals(r.getRelevantTasks().isPresent(), isRelevantTasksExpected);
        if(isRelevantTasksExpected){
            assertEquals(lastShownList, r.getRelevantTasks().get());
        }

        //Confirm the state of data is as expected
        assertEquals(expectedTasksList, tasksList);
        assertEquals(lastShownList, logic.getLastShownList());
//        assertEquals(tasksList, saveFile.load());
    }


    @Test
    public void execute_unknownCommandWord() throws Exception {
        String unknownCommand = "uicfhmowqewca";
        assertCommandBehavior(unknownCommand, HelpCommand.MESSAGE_ALL_USAGES);
    }

    @Test
    public void execute_help() throws Exception {
        assertCommandBehavior("help", HelpCommand.MESSAGE_ALL_USAGES);
    }

    @Test
    public void execute_exit() throws Exception {
        assertCommandBehavior("exit", ExitCommand.MESSAGE_EXIT_ACKNOWEDGEMENT);
    }

    @Test
    public void execute_clear() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        tasksList.addTask(helper.generateTask(1));
        tasksList.addTask(helper.generateTask(2));
        tasksList.addTask(helper.generateTask(3));

        assertCommandBehavior("clear", ClearCommand.MESSAGE_SUCCESS, TasksList.empty(), false, Collections.emptyList());
    }

/*    @Test
    public void execute_add_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE);
        assertCommandBehavior(
                "add wrong args wrong args", expectedMessage);
        assertCommandBehavior(
                "add Valid Name 12345 e/valid@email.butNoPhonePrefix a/valid, address", expectedMessage);
        assertCommandBehavior(
                "add Valid Name p/12345 valid@email.butNoPrefix a/valid, address", expectedMessage);
        assertCommandBehavior(
                "add Valid Name p/12345 e/valid@email.butNoAddressPrefix valid, address", expectedMessage);
    }*/

/*    @Test
    public void execute_add_invalidTaskData() throws Exception {
        assertCommandBehavior(
                "add []\\[;] p/12345 e/valid@e.mail a/valid, address", TaskDetails.MESSAGE_DETAILS_CONSTRAINTS);
    }*/

    @Test
    public void execute_add_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.aTasks();
        TasksList expectedAB = new TasksList();
        expectedAB.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                              String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded),
                              expectedAB,
                              false,
                              Collections.emptyList());

    }

    /*@Test
    public void execute_view_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewCommand.MESSAGE_USAGE);
        assertCommandBehavior("view ", expectedMessage);
        assertCommandBehavior("view arg not number", expectedMessage);
    }*/

    /*@Test
    public void execute_view_invalidIndex() throws Exception {
        assertInvalidIndexBehaviorForCommand("view");
    }*/

    /**
     * Confirms the 'invalid argument index number behaviour' for the given command
     * targeting a single person in the last shown list, using visible index.
     * @param commandWord to test assuming it targets a single person in the last shown list based on visible index.
     */
    private void assertInvalidIndexBehaviorForCommand(String commandWord) throws Exception {
        String expectedMessage = Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX;
        TestDataHelper helper = new TestDataHelper();
        Task p1 = helper.generateTask(1);
        Task p2 = helper.generateTask(2);
        List<Task> lastShownList = helper.generateTaskList(p1, p2);

        logic.setLastShownList(lastShownList);

        assertCommandBehavior(commandWord + " -1", expectedMessage, TasksList.empty(), false, lastShownList);
        assertCommandBehavior(commandWord + " 0", expectedMessage, TasksList.empty(), false, lastShownList);
        assertCommandBehavior(commandWord + " 3", expectedMessage, TasksList.empty(), false, lastShownList);

    }

    /*@Test
    public void execute_view_onlyShowsNonPrivate() throws Exception {

        TestDataHelper helper = new TestDataHelper();
        Task p1 = helper.generateTask(1);
        Task p2 = helper.generateTask(2);
        List<Task> lastShownList = helper.generateTaskList(p1, p2);
        TasksList expectedAB = helper.generateTasksList(lastShownList);
        helper.addToTasksList(tasksList, lastShownList);

        logic.setLastShownList(lastShownList);

        assertCommandBehavior("view 1",
                              String.format(ViewCommand.MESSAGE_VIEW_TASK_DETAILS, p1.toString()),
                              expectedAB,
                              false,
                              lastShownList);

        assertCommandBehavior("view 2",
                              String.format(ViewCommand.MESSAGE_VIEW_TASK_DETAILS, p2.toString()),
                              expectedAB,
                              false,
                              lastShownList);
    }*/

    /*@Test
    public void execute_tryToViewMissingTask_errorMessage() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task p1 = helper.generateTask(1);
        Task p2 = helper.generateTask(2);
        List<Task> lastShownList = helper.generateTaskList(p1, p2);

        TasksList expectedAB = new TasksList();
        expectedAB.addTask(p2);

        tasksList.addTask(p2);
        logic.setLastShownList(lastShownList);

        assertCommandBehavior("view 1",
                              Messages.MESSAGE_TASK_NOT_IN_TASKSLIST,
                              expectedAB,
                              false,
                              lastShownList);
    }*/

    /*@Test
    public void execute_viewAll_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewAllCommand.MESSAGE_USAGE);
        assertCommandBehavior("viewall ", expectedMessage);
        assertCommandBehavior("viewall arg not number", expectedMessage);
    }*/

    /*@Test
    public void execute_viewAll_invalidIndex() throws Exception {
        assertInvalidIndexBehaviorForCommand("viewall");
    }*/

    /*@Test
    public void execute_viewAll() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task p1 = helper.generateTask(1);
        Task p2 = helper.generateTask(2);
        List<Task> lastShownList = helper.generateTaskList(p1, p2);
        TasksList expectedAB = helper.generateTasksList(lastShownList);
        helper.addToTasksList(tasksList, lastShownList);

        logic.setLastShownList(lastShownList);

        assertCommandBehavior("viewall 1",
                            String.format(ViewCommand.MESSAGE_VIEW_TASK_DETAILS, p1.toString()),
                            expectedAB,
                            false,
                            lastShownList);

        assertCommandBehavior("viewall 2",
                            String.format(ViewCommand.MESSAGE_VIEW_TASK_DETAILS, p2.toString()),
                            expectedAB,
                            false,
                            lastShownList);
    }*/

    /*@Test
    public void execute_tryToViewAllTaskMissingInTasksList_errorMessage() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task p1 = helper.generateTask(1);
        Task p2 = helper.generateTask(2);
        List<Task> lastShownList = helper.generateTaskList(p1, p2);

        TasksList expectedAB = new TasksList();
        expectedAB.addTask(p1);

        tasksList.addTask(p1);
        logic.setLastShownList(lastShownList);

        assertCommandBehavior("viewall 2",
                                Messages.MESSAGE_TASK_NOT_IN_TASKSLIST,
                                expectedAB,
                                false,
                                lastShownList);
    }*/

    @Test
    public void execute_delete_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE);
        assertCommandBehavior("delete ", expectedMessage);
        assertCommandBehavior("delete arg not number", expectedMessage);
    }

    @Test
    public void execute_delete_invalidIndex() throws Exception {
        assertInvalidIndexBehaviorForCommand("delete");
    }

    @Test
    public void execute_delete_removesCorrectTask() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task p1 = helper.generateTask(1);
        Task p2 = helper.generateTask(2);
        Task p3 = helper.generateTask(3);

        List<Task> threeTasks = helper.generateTaskList(p1, p2, p3);

        TasksList expectedAB = helper.generateTasksList(threeTasks);
        expectedAB.removeTask(p2);


        helper.addToTasksList(tasksList, threeTasks);
        logic.setLastShownList(threeTasks);

        assertCommandBehavior("delete 2",
                String.format(DeleteCommand.MESSAGE_DELETE_ITEM_SUCCESS, p2),
                                expectedAB,
                                false,
                                threeTasks);
    }

    @Test
    public void execute_delete_missingInTasksList() throws Exception {

        TestDataHelper helper = new TestDataHelper();
        Task p1 = helper.generateTask(1);
        Task p2 = helper.generateTask(2);
        Task p3 = helper.generateTask(3);

        List<Task> threeTasks = helper.generateTaskList(p1, p2, p3);

        TasksList expectedAB = helper.generateTasksList(threeTasks);
        expectedAB.removeTask(p2);

        helper.addToTasksList(tasksList, threeTasks);
        tasksList.removeTask(p2);
        logic.setLastShownList(threeTasks);

        assertCommandBehavior("delete 4",
                                Messages.MESSAGE_TASK_NOT_IN_TASKSLIST,
                                expectedAB,
                                false,
                                threeTasks);
    }

    @Test
    public void execute_find_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE);
        assertCommandBehavior("find ", expectedMessage);
    }

    @Test
    public void execute_find_onlyMatchesFullWordsInNames() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateTaskWithDetails("bla bla KEY bla");
        Task pTarget2 = helper.generateTaskWithDetails("bla KEY bla bceofeia");
        Task p1 = helper.generateTaskWithDetails("KE Y");
        Task p2 = helper.generateTaskWithDetails("KEYKEYKEY sduauo");

        List<Task> fourTasks = helper.generateTaskList(p1, pTarget1, p2, pTarget2);
        TasksList expectedAB = helper.generateTasksList(fourTasks);
        List<Task> expectedList = helper.generateTaskList(pTarget1, pTarget2);
        helper.addToTasksList(tasksList, fourTasks);

        assertCommandBehavior("find KEY",
                                Command.getMessageForTasksListShownSummary(expectedList),
                                expectedAB,
                                true,
                                expectedList);
    }

    // Might need to re-look this test
    @Test
    public void execute_find_isNonCaseSensitive() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateTaskWithDetails("bla bla KEY bla");
        Task pTarget2 = helper.generateTaskWithDetails("bla KEY bla bceofeia");
        Task p1 = helper.generateTaskWithDetails("key key");
        Task p2 = helper.generateTaskWithDetails("KEy sduauo");

        List<Task> fourTasks = helper.generateTaskList(p1, pTarget1, p2, pTarget2);
        TasksList expectedAB = helper.generateTasksList(fourTasks);
        List<Task> expectedList = helper.generateTaskList(p1, pTarget1, p2, pTarget2);
        helper.addToTasksList(tasksList, fourTasks);

        assertCommandBehavior("find KEY",
                                Command.getMessageForTasksListShownSummary(expectedList),                            
                                expectedAB,
                                true,
                                expectedList);
    }

    @Test
    public void execute_find_matchesIfAnyKeywordPresent() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateTaskWithDetails("bla bla KEY bla");
        Task pTarget2 = helper.generateTaskWithDetails("bla rAnDoM bla bceofeia");
        Task p1 = helper.generateTaskWithDetails("key key");
        Task p2 = helper.generateTaskWithDetails("KEy sduauo");

        List<Task> fourTasks = helper.generateTaskList(p1, pTarget1, p2, pTarget2);
        TasksList expectedAB = helper.generateTasksList(fourTasks);
        List<Task> expectedList = helper.generateTaskList(p1, pTarget1, p2, pTarget2);
        helper.addToTasksList(tasksList, fourTasks);

        assertCommandBehavior("find KEY rAnDoM",
                                Command.getMessageForTasksListShownSummary(expectedList),
                                expectedAB,
                                true,
                                expectedList);
    }

    /**
     * A utility class to generate test data.
     */
    class TestDataHelper{

        Task aTasks() throws Exception {
            TaskDetails taskdetails = new TaskDetails("This is a task");
            return new Task(taskdetails);
        }

        /**
         * Generates a valid task using the given seed.
         * Running this function with the same parameter values guarantees the returned task will have the same state.
         * Each unique seed will generate a unique Task object.
         *
         * @param seed used to generate the person data field values
         */
        Task generateTask(int seed) throws Exception {
            return new Task(new TaskDetails("Task " + seed));
        }

        /** Generates the correct add command based on the task given */
        String generateAddCommand(Task p) {
            StringJoiner cmd = new StringJoiner(" ");

            cmd.add("add");

            cmd.add(p.getDetails().toString());
            return cmd.toString();
        }

        /**
         * Generates an TasksList based on the list of Tasks given.
         */
        TasksList generateTasksList(List<Task> todoTasks) throws Exception{
            TasksList tasksList = new TasksList();
            addToTasksList(tasksList, todoTasks);
            return tasksList;
        }

        /**
         * Adds the given list of Tasks to the given TasksList
         */
        void addToTasksList(TasksList tasksList, List<Task> tasksToAdd) throws Exception{
            for(Task p: tasksToAdd){
                tasksList.addTask(p);
            }
        }

        /**
         * Creates a list of Tasks based on the given Task objects.
         */
        List<Task> generateTaskList(Task... tasks) throws Exception{
            List<Task> taskList = new ArrayList<>();
            for(Task p: tasks){
                taskList.add(p);
            }
            return taskList;
        }

        /**
         * Generates a Task object with given name. Other fields will have some dummy values.
         */
         Task generateTaskWithDetails(String taskdetails) throws Exception {
            return new Task(
                    new TaskDetails(taskdetails));
         }
    }

}
```
